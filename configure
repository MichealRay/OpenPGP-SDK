#!/usr/bin/perl -w

use strict;

use Carp;
use File::Temp;

our %Subst=(
	    'CRYPTO_LIBS' => '-lcrypto',
	   );

my %Args=(
	  '--help' => \&usage,
	  '--use-dmalloc' => sub {
	      $Subst{DM_FLAGS}='-I/usr/local/include -DDMALLOC';
	      $Subst{DM_LIB}='/usr/local/lib/libdmalloc.a';
	  },
	  '--with-openssl=' => sub {
	      my $loc=shift;
	      $Subst{INCLUDES}.=" -I $loc/include";
	      $Subst{CRYPTO_LIBS}="$loc/libcrypto.a";
	  },
	  '--with-zlib=' => sub {
	      my $loc=shift;
	      $Subst{INCLUDES}.=" -I $loc/include";
	  },
	 );

my @Headers=qw(alloca.h);
my @Types=qw(time_t);

our %Knowledge=(
		cc => sub { return chooseBinary('gcc','cc')
			     || croak 'Can\'t find C compiler'; },
		path => sub { return [split /:/,$ENV{PATH}]; },
		time_t => sub { return typeInfo('time_t','time.h'); }
	      );

while(my $arg=shift) {
    my $arg2;
    if($arg =~ /^(.+=)(.+)$/) {
	$arg=$1;
	$arg2=$2;
    }
    my $code=$Args{$arg};
    croak "Don't understand: $arg" if !defined $code;
    &$code($arg2);
}

#my $os=`uname -s`;

$Subst{'CC'}=getKnowledge('cc');

findHeaders(\@Headers);
investigateTypes(\@Types);

fixSubst();

create('src/.depend');
create('examples/.depend');

fileSubst('src/Makefile','#','');
fileSubst('examples/Makefile','#','');
fileSubst('include/configure.h','/*','*/');

print "make clean\n";
system 'make clean' || exit;
print "make force_depend\n";
system 'make force_depend' || exit;

sub subst {
    my $line=shift;

    while(my($k,$v)=each %Subst) {
	$line =~ s/\%$k\%/$v/g;
    }
    $line =~ s/\%.+?\%//g;
    return $line;
}

sub chooseBinary {
    my $path=getKnowledge('path');
    while(my $bin=shift) {
	foreach my $p (@$path) {
	    return $bin if -x "$p/$bin";
	}
    }
    return 'false';
}

sub getKnowledge {
    my $thing=shift;

    croak "Asked for nonexistent knowledge $thing"
      if !exists $Knowledge{$thing};

    if(ref $Knowledge{$thing} eq 'CODE') {
	print "Finding $thing\n";
	$Knowledge{$thing}=&{$Knowledge{$thing}}();
    }
    return $Knowledge{$thing};
}

sub usage {
    foreach my $k (keys %Args) {
	print "$k\n";
    }
    exit;
}

sub findHeaders {
    my $list=shift;

    foreach my $h (@$list) {
	my $n='HAVE_'.uc $h;
	$n =~ s/[\.\/]/_/;
	print "Looking for header $h ($n)\n";
	if(-e "/usr/include/$h") {
	    $Subst{$n}="#define $n 0";
	} else {
	    $Subst{$n}="#undef $n";
	}
    }
}

sub fileSubst {
    my $file=shift;
    my $cs=shift;
    my $ce=shift;

    open(T,"$file.template") || croak "Can't open $file.template: $!";
    unlink $file;
    open(M,">$file") || croak "Can't create $file: $!";

    print M "$cs generated by configure from $file.template. Don't edit. $ce\n\n";

    while(my $line=<T>) {
	print M subst($line);
    }

    close M;
    close T;

    chmod 0444,"$file";
}

sub fixSubst {
    foreach my $k (keys %Subst) {
	$Subst{$k} =~ s/~/$ENV{HOME}/g;
    }
}

sub create {
    my $file=shift;

    print "Creating $file\n";
    open(D,">$file") || croak "Can't create $file";
    close D;
}

sub build {
    my $code=shift;

    my $cc=getKnowledge('cc');
    my $fh=new File::Temp(SUFFIX => '.c');
#    print $fh->filename(),"\n";
    print $fh $code;
#    print $code;
    $fh->close();

    my $cmd="$cc -Wall -Werror -c ".$fh;
#    print "$cmd\n";
    my $ret=system("$cmd > /dev/null 2>&1");

    return $ret == 0;
}

sub typeInfo {
    my $type=shift;
    my $header=shift;

    my %info;

    print "Getting info about $type.\n";

    foreach my $fmt (qw(%d %ld)) {
	my $code="#include <$header>\n";
	$code .= "#include <stdio.h>\n";
	$code .= "void f(void) { static $type t; printf(\"$fmt\",t); }\n";
	if(build($code)) {
	    $info{fmt}=$fmt;
	    print "  $type printf format is $fmt\n";
	}
    }
    croak "Can't determine print format for $type" if !defined $info{fmt};

    return \%info;
}

sub investigateTypes {
    my $types=shift;

    foreach my $type (@$types) {
	my $info=getKnowledge($type);
	$Subst{uc($type)."_FMT"}="\"$info->{fmt}\"";
    }
}

